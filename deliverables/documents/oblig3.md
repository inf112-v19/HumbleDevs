<H2>Mandatory exercise 3<H/2>	
					

<H3>Part 1: Project and project structure<H/3>


We are group g4_team3 - HumbleDevs


<H4> Current roles:<H/4>


Teamlead: Amalie

Customer contact: Linh

Libgdx (frontend): Joachim and Bendik

Game logic: Even



<H5>How do the roles of the team work?<H/5>

- We agree about that we may have had unclear roles, about the tasks and what to do.
- Customer contact seems like an unnecessary role, since everyone need to know just as much about the game and because there have been no “customer contact”.

<H5>Do you need to update who is teamlead or customer contact?<H/5>

- No, we are pleased with Amalie as our teamlead.

<H5>Do you need other roles? <H/5>
        
- No, but we need to be more specific about current roles

Revised roles:

Teamlead: Amalie

- Meet referating, Project Board, Item classes

Customer contact: Linh

- Control over the customers requirements, card class

Libgdx: Joachim and Bendik

- Libgdx “pros”, 

Class design: Even

- Backend

<H5>Write down some points about what the different roles actually mean to you.<H/5>
        
- The roles means that everyone has their own responsibility to contribute to the progress of the game
- Everyone in the group is comfortable with their assigned task

<H5>Are there any experiences either team-wise or regarding project methodology that is worth mentioning?<H/5>
        
- We have had great success with pair-programming when some of us have been stuck on a problem. It has always solved the problem and it has also contributed to a better understanding of both our implementation and programming in general. Pair programming is therefore something we would like to do even more in the upcoming periods.
- We have also thought about reviewing the code more frequently in plenary, so that everyone knows how the game works, and why we have made it like this.
- We have been better at using the github project board and we all agree on that it has helped us structure the project more than before. Still, there is room for improvement. We could make the subtasks even smaller, which will give an even better overview of the project and what needs to be done. This will highlight the missing parts and everyone on the group will always have something to do.

<H5> Does the team think the choices you've made are good? If not, what can you do differently to improve the way the team works? <H/5>
        
- We are overall satisfied with the important choices we have made so far, but we have made minor technical choices about the game that haven’t been optimal, e.g.
We have made some poor decisions when it comes to Libgdx. We started by doing it in a way that was way too complicated, but it’s not surprising to make bad decision when you have little to no knowledge about the subject in advance.
- We are pleased with most of our choices and doesn’t think there are much to change, but we may want to discuss the important choices more openly with the whole group. That will increase everyone knowledge about the issues we are facing, and an understanding of why we choose to do something in a particular way is important that everyone is aware of.

							
<H5>How are the group dynamics? How does communication work for you? <H/5>

- Slack notification can sometimes be slow and that has created some troubles, but we are now aware of the issue. More importantly, we are satisfied, apart from the notification issue, with using Slack as our platform of communication and will keep on using it.
- We think that our group has good communication and that we fit well together. 


<H5>Make a brief retrospective in which you consider what you have done so far and what can be improved. This is about project structure, not code. You can of course discuss code, but this is not about error correction, but about how to work and communicate.<H/5>

- We need to have a more clear communication, where everyone is secure about their assigned task.
- There should also be a more updated project board. We have talked about that we should assign and write down smaller tasks, so that it is easier to implement. 
- We should also be better to review the code together and explain why and what we have done during the programming.
- So far, we have become better at using git, but there is still some confusion about how the master merge works, and how we fix the conflicts that occurs.
- Attacking the problems in subgroups: Programming in subgroups (“pair programming”)

<H5>During evaluation, every member's contribution to the code base will be emphasized. If there is a big difference in who commits, you must enclose a brief explanation as to why it is like that. Remember to commit everything. Including design files.<H/5>

Report from meetings since the previous delivery must also be delivered.
From the retrospective agree and write down three things (max), that the team will follow up during the next sprint.
- Code review
- Subdivision of tasks
- Attacking the problems in subgroups: Programming in subgroups (“pair programming”)
							
<H2>Part 2: requirements<H/2>
        

<H5>Clarification of the customer's requirements. What are the actual tasks? How do the team Prioritize these tasks?<H/5>
- Our main priority has been the map so far. We have updated the project board after the requirements, and divided the tasks. 

<H5>If changes are made in order from what is given by the customer, why is this done?<H/5>

<H5>How will you verify that the requirements are met? (What are the acceptance criteria?)<H/5>
- By writing updated tests.
- Retrospective meetings

<H5>Update what your priorities are, how far you have come and what you have done since last time. The list of requirements is long, but it is not necessary to deliver on all requirements if it is not realistic. It is more important that the tasks that you've executed are of high quality. Regard subproblem 4: "Completed tasks must be finished."<H/5>
        
- Our main priority is to finish the board and the GUI. We also work on all the Item classes, and Card package. We have had some serios problems regarding the GUI and it has proven difficult to use Lidgdx. We have in the last days found a solution, but this has set us back quite a bit. This means that we do not meet all the requirements e.g. we will not meet the requirement to “choose five cards”. The GUI is behind, and we would like to know how the implementation should be graphically before we make the backend solution.

- It is possible to play one round, but there are some methods that are not implemented yet, like shootLasers(). See the comments in the Game – class to get a better understanding of what has been done and why.

- On the other hand, we have made other things that wasn’t requirements for this assignment, but that we felt like would be nice to have at this point. Most of them is in the Game – class. We have also made all the cards and items we need.
 
- Our next goal is to get the GUI up to speed and make most of the game logic. So, for the next assignment we would like a to have implemented most the game logic and be able to visualize most of our game.  

**Note:** We have noticed that the rules we are given sometimes deviates slightly from what the official rulebook says. It is therefore some uncertainty about what our rules should be. This will be clarified to the next assignment.

						
<H3>Part 3: Code<H/3>
							
<H5>You need to document how the project builds, tests, and runs such that it's easy to test the code. During evaluation, the code will also be user tested.<H/5>
Document how the tests should be run, as well.
TBA

<H5>Code quality and test coverage are emphasized. Note that the tests you write must be used in the product. Completed tasks must be finished. Deliver class diagrams. (If there are many classes, make class diagrams for the most important ones.)<H/5>
<H/5>cho
Class Diagram:
TBA
